PARSER_BEGIN(ProyectoFase3)
/** Simple brace matcher. */
public class ProyectoFase3 {
        public static int countloc=0x00;
        public static TablaSimbolos tabla= new TablaSimbolos();
 
  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
    ProyectoFase3 parser = new ProyectoFase3(System.in);
    parser.Estructura();
    System.out.println("Analisis Finalizado:");
  }
}
PARSER_END(ProyectoFase3)
/*Elementos a ignorar*/
SKIP :
{
  " " | "\t" | "\n" | "\r"
}
/*Seccion de tokens*/
TOKEN :
{
     /*ATRIBUTOS*/
    <BY: "B"> |
    <WO: "W"> |
    <LO: "L"> |
    
    /*LITERALES NUMERICAS*/
        <D8: (<D8D>|<D8H>|<D8O>|<D8B>)>|//reconoce los D8
      <D8B: "B"(<DIG_BINARIO>){1,8}>|//Reconoce números binarios de hasta 8 bits
      <D8D: (<DIG>|("1"(<DIG>){1,2})
                 |("2"["0"-"4"]<DIG>)
                 |("25"["0"-"5"]))>|//Reconoce números decimales de hasta 8 bits
      <D8H: "$"(<DIG_HEXA>){1,2}>|//Reconoce números hexadecimales de hasta 8 bits
      <H8: "$"(<DIG_HEXA>){1,2}>|//Reconoce de 1 a 2 digitos en hexadecimal
      <D8O: "0"((["1"-"3"])?(<DIG_OCTAL>){1,2})>|//Reconoce números octales de hasta 8 bits
      
      //d16
      <D16: (<D16D>|<D16H>|<D16O>|<D16B>)>|//reconoce los D16
      <D16B: "B"(<DIG_BINARIO>){1,16}>|//Reconoce números binarios de hasta 16 bits
      <D16D: (<DIG>
             |(["1"-"5"](<DIG>){1,4})
             |("6"["0"-"4"](<DIG>){1,3})
             |("65"["0"-"4"](<DIG>){1,2})
             |("655"["0"-"2"]<DIG>)
             |("6553"["0"-"6"])
             )>|//Reconoce números decimales de hasta 16 bits
      <D16O: "0"(("1")?(<DIG_OCTAL>){1,5})>|//Reconoce números octales de hasta 16 bits
      <D16H: "$"(<DIG_HEXA>){1,4}>|//Reconoce números hexadecimales de hasta 16 bits
      <H16: "$"(<DIG_HEXA>){1,4}>|//Reconoce de 1 a 4 digitos en hexadecimal
      //d32
      <D32: (<D32D>|<D32H>|<D32O>|<D32B>)>|//reconoce los D32
      <D32B: "B"(<DIG_BINARIO>){1,32}>|//Reconoce números binarios de hasta 32 bits
      <D32D: (<DIG>
             |(["1"-"3"](<DIG>){1,9})
             |("4"["0"-"1"](<DIG>){1,8})
             |("42"["0"-"8"](<DIG>){1,7})
             |("429"["0"-"3"](<DIG>){1,6})
             |("4294"["0"-"8"](<DIG>){1,5})
             |("42949"["0"-"5"](<DIG>){1,4})
             |("429496"["0"-"6"](<DIG>){1,3})
             |("4294967"["0"-"1"](<DIG>){1,2})
             |("42949672"["0"-"8"]<DIG>)
             |("429496729"["0"-"5"])
             )>|//Reconoce números decimales de hasta 32 bits
      <D32O: "0"((["1"-"3"])?(<DIG_OCTAL>){1,10})>|//Reconoce números octales de hasta 32 bits
      <D32H: "$"(<DIG_HEXA>){1,8}>|//Reconoce números hexadecimales de hasta 32 bits

      <DIG: ["0"-"9"]> |//Reconoce un digito del 0 al 9
      <NUM_DECIMAL: (["1"-"9"](<DIG>)*)>|
      <DIG_BINARIO: "0"|"1">|//token para un digito binario
      <DIG_HEXA: (["A"-"F"]|["a"-"f"]|<DIG>)>|//token para un digito hexadecimal
      <DIG_OCTAL: ["0"-"7"]>|//token para un digito octal


   /*SIMBOLOS ESPECIALES*/
    <Mas: "+"> |
    <Guion: "-">  |
    <Diagonal: "/">  |
    <Asterisco: "*">  |
    <ParentesisA: "("> |
    <ParentesisC: ")">  |
    <CorcheteA: "["> |
    <CorcheteC: "]">  |
    <LlaveA: "{"> |
    <LlaveC: "}">  |
    <DosPuntos: ":">  |
    <PuntoComa: ";">  |
    <Punto: "."> |
    <Coma: ",">  |
    <Apersant: "&">|
    <Linea: "|"> |
    <Admiracion: "!">  |
    <Pesos: "$">  |
    <Porcentaje: "%">|
    <Gato: "#">  |
    /*COMENTARIOS*/
    <Comentario: "//"(~["\n"])+> |
    /*DIRECTIVAS*/
    <CODE: "CODE">  |
    <ORG: "ORG">  |
    <DDATA: "DDATA">  |
    <BYTE: "BYTE"> |
    <WORD: "WORD">  |
    <LONG: "LONG">  |
    <EXT: "EXT">  |
    <DEF: "DEF">  |
    <EQU: "EQU">  |
    <END: "END">  |
   /*REGISTROS*/
    <Datos: "D"["0"-"7"]>  |
    <Memoria: "A"["0"-"7"]> |
    <PC: "PC">  |
    <SR: "SR"> |
    <CCR: "CCR">  |
    <SP: "SP"> |
    /*MNEMOTECNICOS TABLA 3.2 (15 INSTRUCCIONES)*/
    <EXG: "EXG"> |
    <FMOVE: "FMOVE">  |
    <FSMOVE: "FSMOVE"> |
    <FDMOVE: "FDMOVE">  |
    <FMOVEM: "FMOVEM"> |
    <LEA: "LEA">  |
    <LINK: "LINK">  |
    <MOVE: "MOVE">  |
    <MOVE16: "MOVE16">  |
    <MOVEA: "MOVEA">  |
    <MOVEM: "MOVEM">  |
    <MOVEP: "MOVEP">  |
    <MOVEQ: "MOVEQ">   |
    <PEA: "PEA">   |
    <UNLK: "UNLK">   |
    /*MNEMOTECNICOS TABLA 3.3 (26 INSTRUCCIONES)*/
    <ADD: "ADD">   |
    <ADDA: "ADDA">   |
    <ADDI: "ADDI">   |
    <ADDQ: "ADDQ">   |
    <ADDX: "ADDX">   |
    <CLR: "CLR">   |
    <CMP: "CMP">   |
    <CMPA: "CMPA">   |
    <CMPI: "CMPI">   |
    <CMPM: "CMPM">   |
    <CMP2: "CMP2">   |
    <DIVS: "DIVS">   |
    <DIVU: "DIVU">   |
    <DIVSL: "DIVSL">   |
    <DIVUL: "DIVUL">   |
    <EXTB: "EXTB">   |
    <MULS: "MULS">   |
    <MULU: "MULU">   |
    <NEG: "NEG">   |
    <NEGX: "NEGX">   |
    <SUB: "SUB">   |
    <SUBA: "SUBA">   |
    <SUBI: "SUBI">   |
    <SUBQ: "SUBQ">   |
    <SUBX: "SUBX">   |
    /*MNEMOTECNICOS TABLA 3.4 (7 INSTRUCCIONES)*/
    <AND: "AND">   |
    <ANDI: "ANDI">   |
    <EOR: "EOR">   |
    <EORI: "EORI">   |
    <NOT: "NOT">   |
    <OR: "OR">   |
    <ORI: "ORI">   |
    /*MNEMOTECNICOS TABLA 3.5 (9 INSTRUCCIONES)*/
    <ASL: "ASL">   |
    <ASR: "ASR">   |
    <LSL: "LSL">   |
    <LSR: "LSR">   |
    <ROL: "ROL">   |
    <ROR: "ROR">   |
    <ROXL: "ROXL">   |
    <ROXR: "ROXR">   |
    <SWAP: "SWAP">   |
    /*MNEMOTECNICOS TABLA 3.6 (4 INSTRUCCIONES)*/
    <BCHG: "BCHG">   |
    <BCLR: "BCLR">   |
    <BSET: "BSET">   |
    <BTST: "BTST">   |
    /*MNEMOTECNICOS TABLA 3.7 (8 INSTRUCCIONES)*/
    <BFCHG: "BFCHG">   |
    <BFCLR: "BFCLR">   |
    <BFEXTS: "BFEXTS">   |
    <BFEXTU: "BFEXTU">   |
    <BFFFO: "BFFFO">   |
    <BFINS: "BFINS">   |
    <BFSET: "BFSET">   |
    <BFTST: "BFTST">   |
    /*MNEMOTECNICOS TABLA 3.8*/
    <ABCD: "ABCD">   |
    <NBCD: "NBCD">   |
    <PACK: "PACK">   |
    <SBCD: "SBCD">   |
    <UNPK: "UNPK">   |
    /*MNEMOTECNICOS TABLA 3.9 (17 INSTRUCCIONES)*/
    <Bcc: "Bcc">   |
    <FBcc: "FBcc">   |
    <DBcc: "DBcc">   |
    <FDBcc: "FDBcc">   |
    <Scc: "Scc">   |
    <FScc: "FScc" >  |
    <BRA: "BRA">   |
    <BSR: "BSR">   |
    <JMP: "JMP">   |
    <JSR: "JSR">   |
    <NOP:"NOP">   |
    <FNOP: "FNOP">   |
    <RTD: "RTD">   |
    <RTR: "RTR">   |
    <RTS: "RTS">   |
    <TST: "TST">   |
    <FTST: "FTST">   |
    /*MNEMOTECNICOS TABLA 3.10*/
    <FRESTORE: "FRESTORE">   |
  <FSAVE: "FSAVE">   |
  <MOVEC: "MOVEC">   |
  <MOVES: "MOVES">   |
  <RESET: "RESET">   |
  <RTE: "RTE">   |
  <STOP: "STOP">   |
  <BKTP: "BKTP">   |
  <CHK: "CHK">   |
  <CHK2: "CHK2">   |
  <ILEGAL: "ILEGAL">   |
  <TRAP: "TRAP">   |
  <TRAPcc: "TRAPcc">   |
  <FTRAPcc: "FTRAPcc">   |
  <TRAPV: "TRAPV">   |
    /*CONDICIONALES*/
    <CC: "CC">    | 
    <LS:"LS">   |
    <CS: "CS">    |
    <LT: "LT">    |
    <EQ: "EQ">    |
    <MI: "MI">    |
    <NE: "NE"> {System.out.println("Line:   "+matchedToken.beginLine+" Condicional("+image+")");} |
    <GE: "GE">    |
    <PL: "PL">    |
    <GT: "GT">    |
    <T: "T">    |
    <HI: "HI">    |
    <VC: "VC">    |
    <LE: "LE">    |
    <VS: "VS">    |
    /*IDENTIFICADORES*/
    <Identificador: <LETRA>(<LETRA> | <DIG>){0,7}>  |
    <LETRA: (["a"-"z"]|["A"-"Z"])>|
    <CADENA: <LETRA>(<LETRA>|<DIG>)+>
    
}
/*METODOS PARA ESTRUCTURA DEL PROGRAMA*/


void Estructura(): {}
{

    <Identificador><ORG>(<D32>|<D16>|<D8>)Directivas_Est()Instrucciones_Est(){System.out.println("\n");tabla.imprimir();}<END><EOF>{System.out.println("No hay errores sintacticos");}
}

void Directivas_Est(): {
    Token id;
}
{
    (id=<Identificador>Directivas(id))*
}

void Instrucciones_Est(): {
    Token id;
    String Identi="";
}
{
    <Punto><CODE>((id=<Identificador>{
                        if(!tabla.existe(id.image)){
                            tabla.insertar(id.image, countloc, "DIR"); 
                            Identi=id.image;
                        }
                        else{
                            System.out.println("Error! el ID \""+id.image+"\" ya existe!");
                            java.lang.System.exit(1);
                        }
                    }   
    )?Instrucciones(Identi))+
}

void Instrucciones(String Identi): {}
{
    (BCHG(Identi)|PACK(Identi)|ADD_METODO(Identi)|JMP_Metodo(Identi)|SBCD(Identi)|CMP(Identi)|LSL(Identi)|EOR(Identi))
}
/*FIN METODOS PARA ESTRUCTURA DEL PROGRAMA*/

/*METODOS PARA CREAR LAS DIRECTIVAS*/
void Directivas(Token id) : {}
{
    ((DDATA(id)|BWLEDE(id)))
}

void DDATA(Token id): {
 int multi=1;
 String Identi= id.image;
 int bytesOcupados=0;
 String TipoDato="DB";
}
{
    <DDATA>{
        multi=Tamanio();
        switch(multi){
            case 1:
                TipoDato="DB";
                break;
            
            case 2:
                TipoDato="DW";
                break;
            
            case 4:
                TipoDato="DL";
                break;
            
        }
        bytesOcupados=Valor();
        {
            if (!tabla.existe(Identi)) {
                tabla.insertar(Identi,countloc,TipoDato);
            }
            else{
                System.out.println("Error el ID \""+Identi+"\"Ya se encuentra");
                java.lang.System.exit(0);
            }
                countloc=(countloc)+(bytesOcupados*multi);
                tabla.setTam(Identi, bytesOcupados*multi);
        }
    }
}

void BWLEDE(Token id): {
    String Identi=id.image;  
    int bytes=0;
    int aux;
}
{
    (<BYTE>{
        aux=1;
        if(!tabla.existe(Identi)){
                  tabla.insertar(Identi, countloc, "B"); 
              }else{
                System.out.println("Error! el ID \""+Identi+"\" ya existe!");
                java.lang.System.exit(1);
              }
    }
    |
    <WORD>{
        aux=2;
        if(!tabla.existe(Identi)){
                  tabla.insertar(Identi, countloc, "W"); 
              }else{
                System.out.println("Error! el ID \""+Identi+"\" ya existe!");
                java.lang.System.exit(1);
              }
    }
    |<LONG>{
        aux=3;
        if(!tabla.existe(Identi)){
                  tabla.insertar(Identi, countloc, "L"); 
              }else{
                System.out.println("Error! el ID \""+Identi+"\" ya existe!");
                java.lang.System.exit(1);
              }
    }
    |
    <EQU><CADENA>{
        aux=4;
        if(!tabla.existe(Identi)){
                  tabla.insertar(Identi, countloc, "EQU"); 
              }else{
                System.out.println("Error! el ID \""+Identi+"\" ya existe!");
                java.lang.System.exit(1);
              }
    }
    |
    <EXT><CADENA>{
        aux=5;
        if(!tabla.existe(Identi)){
                  tabla.insertar(Identi, countloc, "EXT"); 
              }else{
                System.out.println("Error! el ID \""+Identi+"\" ya existe!");
                java.lang.System.exit(1);
              }
    }
    |
    <DEF><CADENA>{
        aux=6;
        if(!tabla.existe(Identi)){
                  tabla.insertar(Identi, countloc, "DEF"); 
              }else{
                System.out.println("Error! el ID \""+Identi+"\" ya existe!");
                java.lang.System.exit(1);
              }
    }
    )Valor2(aux, id)
}
/*FIN METODOS PARA CREAR LAS DIRECTIVAS*/

/*METODOS INSTRUCCION PACK Y MOVEC*/
/*********************MATTA***************************/
void PACK(String Identi): {
    int bytesOcupados=0x1;
}
{
    (<PACK>((PACK_RM()<Coma>PACK_RM())|(<Datos><Coma><Datos>))){    
        countloc=(countloc)+(bytesOcupados*2);
        System.out.println("DIRECTIVA PACK "+Identi+" tam: "+bytesOcupados);
        tabla.setTam(Identi, bytesOcupados*2);
    }(<Comentario>)?
}

void PACK_RM(): {}
{
    <Guion><ParentesisA><Memoria><ParentesisC>
}

void BCHG(String Identi): {}
{
    <BCHG>(<Punto>(<LO>|<BY>))?BCHG_VAR(Identi)(<Comentario>)?
}

void BCHG_VAR(String Identi): {
    int bytesOcupados=0x1;
}
{
    <Datos><Coma>BCHG_EA(bytesOcupados, Identi) | <Gato>(<D32>{bytesOcupados=bytesOcupados+4;}|<D16>{bytesOcupados=bytesOcupados+2;}|<D8>{bytesOcupados=bytesOcupados+2;})<Coma>BCHG_EA(bytesOcupados, Identi)
}

void BCHG_EA(int bytesOcupados, String Identi): {}
{
    (<Datos> |
    <Guion><ParentesisA><Memoria><ParentesisC> | 
    <ParentesisA>((
                     (<D16>) ( <Coma><Memoria><ParentesisC>{bytesOcupados++;} | <ParentesisC><Punto>(<WO>{bytesOcupados++;}|<LO>{bytesOcupados=bytesOcupados+2;}) )  | 
                     (<D8>)<Coma><Memoria><Coma>(<Memoria>|<Datos>)<ParentesisC>{bytesOcupados++;}
    ) | <Memoria><ParentesisC>(<Mas>)?))
    {    
        countloc=(countloc)+(bytesOcupados*2);
        tabla.setTam(Identi, bytesOcupados*2);
    }
}
/*******************FIN*MATTA***************************/
/*FIN METTODOS INSTRUCCION PACK y MOVEC*/

/*METODOS INSTRUCCIONES JMP Y ADD*/

void JMP_Metodo(String id):{}
{
    <JMP>JMP_Ea(id)(<Comentario>)?
}


void JMP_Ea(String id):{
  int bytesOcupados=0x1;
  int multi=2;

}
{

<ParentesisA>
(   <Memoria><ParentesisC>|((<D16>{bytesOcupados++;})((<ParentesisC><Punto>(<WO>{bytesOcupados++;}|<LO>{bytesOcupados+=2;})|<Coma>(<Memoria>|<PC>)<ParentesisC>)))
|(<D8>{bytesOcupados++;})<Coma>(<Memoria>|<PC>)<Coma>(<Datos>|<Memoria>)<ParentesisC> )
    {
    System.out.println("Instruccion JMP");
     System.out.println("DIRECTIVA JMP "+id+" tam: "+bytesOcupados);
    countloc+=bytesOcupados*multi;
    tabla.setTam(id,bytesOcupados*multi); }
}


void ADD_METODO(String id):{}
{
  <ADD>(<Punto>(<BY>|<WO>|<LO>))?( <Datos><Coma>(ADD_Ea2(id)|<Datos>)|ADD_Ea1(id)<Coma><Datos> )(<Comentario>)?
}

void ADD_Ea1(String id):{
  int bytesOcupados=0x1;
  int multi=2;
}
{
(
<Memoria> |
    <Guion><ParentesisA><Memoria><ParentesisC>  |
    <ParentesisA>(
        <Memoria><ParentesisC>(<Mas>)?|
        (<D16>{bytesOcupados++;})(
            <Coma>(<Memoria>|<PC>)<ParentesisC>|
            <ParentesisC><Punto>(<WO>{bytesOcupados++;}|<LO>{bytesOcupados+=2;})

            )|
        (<D8>{bytesOcupados++;})<Coma>(<Memoria>|<PC>)<Coma>(<Datos>|<Memoria>)<ParentesisC>

        )
    |<Gato>(<D16>{bytesOcupados+=2;}|<D32>{bytesOcupados+=4;}|<D8>{bytesOcupados+=2;})
    )
 {
    System.out.println("Instruccion ADD");

    countloc+=bytesOcupados*multi;
    System.out.println("DIRECTIVA ADD "+id+" tam: "+bytesOcupados);
    tabla.setTam(id,bytesOcupados*multi); 
}
}

void ADD_Ea2(String id):{}
{
    (<ParentesisA>((<D16>)<ParentesisC><Punto>(<WO>|<LO>)|<Memoria><ParentesisC>(<Mas>)?
            (<D16>)<Coma><Memoria><ParentesisC>|
            (<D8>)<Coma><Memoria><Coma>(<Datos>|<Memoria>)<ParentesisC>)
            )
    |<Guion><ParentesisA><Memoria><ParentesisC>
    
}

/*FIN METODOS INSTRUCCIONES JMP Y ADD*/

/*METODOS INSTRUCCIONES CMP Y SBCD*/
void SBCD(String id):{}
{
    <SBCD>(<Punto><BY>)?SBCD_VAR(id)(<Comentario>)?
}

void SBCD_VAR(String id): {
  int bytesOcupados=0x1;
  int temp=0;
}
{
    (<Datos><Coma><Datos>|<Guion><ParentesisA><Memoria><ParentesisC><Coma><Guion><ParentesisA><Memoria><ParentesisC>)
{
    System.out.println("Instruccion SBCD");
        temp=bytesOcupados*2;
      System.out.println("DIRECTIVA SBCD "+id+" tam: "+bytesOcupados);
    countloc+=temp;
    tabla.setTam(id,temp); 
}
}
/**************************MATTA*********************/
void CMP(String Identi):{}
{
    <CMP>(<Punto>(<BY>|<LO>|<WO>))?CMP_EA(Identi)<Coma><Datos>(<Comentario>)?
}

void CMP_EA(String Identi): {
    int bytesOcupados=0x1;
}
{
    ((<Datos>|<Memoria>) |
    <Guion><ParentesisA><Memoria><ParentesisC> | 
    <ParentesisA>((
                     ((<D16>) ( <Coma>(<Memoria>{bytesOcupados++;}|<PC>{bytesOcupados++;})<ParentesisC> | <ParentesisC><Punto>(<WO>{bytesOcupados++;}|<LO>{bytesOcupados=bytesOcupados+2;}) ))  | 
                     (<D8>)<Coma>(<Memoria>|<PC>)<Coma>(<Memoria>|<Datos>)<ParentesisC>{bytesOcupados++;}
    ) | <Memoria><ParentesisC>(<Mas>)?) |
    <Gato>(<D32>{bytesOcupados=bytesOcupados+4;}|<D16>{bytesOcupados=bytesOcupados+2;}|<D8>{bytesOcupados=bytesOcupados+2;}))
    {    
        countloc=(countloc)+(bytesOcupados*2);
        System.out.println("DIRECTIVA CMP "+Identi+" tam: "+bytesOcupados);
        tabla.setTam(Identi, bytesOcupados*2);
    }
    
}
/**************************FIN MATTA*********************/
/*FIN METODOS INSTRUCCIONES CMP Y BCSD*/

/*METODOS INSTRUCCIONES EOR Y LSL-LSR*/
/***************************MATTA***********************/
void LSL(String Identi): {}
{
    (<LSL>(<Punto>(<BY>|<LO>|<WO>))?|<LSR>(<Punto>(<BY>|<LO>|<WO>))?)LSL_VAR(Identi)(<Comentario>)?
}

void LSL_VAR(String Identi): {
    int bytesOcupados=0x1;
}
{
    <Datos><Coma><Datos> |
    <Gato>(<D32>{bytesOcupados=bytesOcupados+4;}|<D16>{bytesOcupados=bytesOcupados+2;}|<D8>{bytesOcupados=bytesOcupados+2;})<Coma><Datos> |
    LSL_EA(Identi, bytesOcupados)
}

void LSL_EA(String Identi, int bytesOcupados): {}
{
    (<Guion><ParentesisA><Memoria><ParentesisC> | 
    <ParentesisA>(
                    (<D16>(<Coma><Memoria><ParentesisC>{bytesOcupados++;}  
                    | 
                    <ParentesisC><Punto>(<WO>{bytesOcupados++;} |<LO>{bytesOcupados=bytesOcupados+2;}))   
                    | 
                    (<D8><Coma><Memoria><Coma>(<Memoria>|<Datos>)<ParentesisC>{bytesOcupados++;}) | 
                    <Memoria><ParentesisC>(<Mas>)?)))
    {    
        countloc=(countloc)+(bytesOcupados*2);
        System.out.println("DIRECTIVA LSL "+Identi+" tam: "+bytesOcupados);
        tabla.setTam(Identi, bytesOcupados*2);
    }
}
/****************************FIN MATTA*******************/

void EOR(String id): {}
{
    <EOR>(<Punto>(<BY>|<LO>|<WO>))?<Datos><Coma>EOR_EA( id)(<Comentario>)?
}

void EOR_EA(String id): {
  int bytesOcupados=0x1;
  int multi=2;

}
{
    (
<Datos> |
    <Guion><ParentesisA><Memoria><ParentesisC>  |
    <ParentesisA>(
        <Memoria><ParentesisC>(<Mas>)?|
        (<D16>)(
            <Coma><Memoria><ParentesisC>{bytesOcupados++;System.out.println("Resultados:"+bytesOcupados);}|
            <ParentesisC><Punto>(<WO>{bytesOcupados++;}|<LO>{bytesOcupados+=2;})

            )|
        (<D8>)<Coma><Memoria><Coma>(<Datos>|<Memoria>)<ParentesisC>{bytesOcupados++;}

        )   
    )

{
    System.out.println("Instruccion EOR");
    countloc+=bytesOcupados*multi;
    System.out.println("DIRECTIVA EOR "+id+" tam: "+bytesOcupados);
    tabla.setTam(id,bytesOcupados*multi); 
}

}
/*FIN METODOS INSTRUCCIONES EOR Y LSL-LSR*/

/*METODOS PARA ASIGNAGION DE TAMAÑO Y VALOR*/
int Tamanio(): {
    int mult;
    int TipoDato2;
}
{
    <Punto>(<BY>{mult=1;}|<WO>{mult=2;}|<LO>{mult=4;})
   { return mult;}
}

int Valor(): {
    int bytes;
}
{
   (<D32>{bytes=4;}|<D16>{bytes=2;}|<D8>{bytes=1;})
   {return bytes;}
}


void Valor2(int aux, Token id): {
    int bytes=0;
    String Identi=id.image;
}
{
    (<D32>{bytes=bytes+4;}|<D16>{bytes=bytes+2;}|<D8>{bytes=bytes+1;})?
    {
      
    switch(aux){
    case 1:
        System.out.println("DIRECTIVA BYTE "+Identi+" tam: "+bytes);
        countloc=(countloc)+(bytes);
        tabla.setTam(Identi, bytes);
    break;
    case 2:
        System.out.println("DIRECTIVA WORD id "+Identi+" tam: "+bytes*2);
        countloc=(countloc)+(bytes*2);
        tabla.setTam(Identi, bytes*2);
    break;
    case 3:
        System.out.println("DIRECTIVA LONG id "+Identi+" tam: "+bytes*4);
        countloc=(countloc)+(bytes*4);
        tabla.setTam(Identi, bytes*4);
    break;
    case 4:
        System.out.println("DIRECTIVAB EQU id "+Identi);
    break;
    case 5:
        System.out.println("DIRECTIVA  EXT id "+Identi);
    break;
    case 6:
        System.out.println("DIRECTIVA DEF id "+Identi);
    break;
    }
   }
}

/*FIN METODOS PARA ASIGNAGION DE TAMAÑO Y VALOR*/